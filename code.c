/***************************************************
程序功能：光电定位仪主程序
----------------------------------------------------
****************************************************/

#include  <msp430x14x.h>
#include  <math.h>
#include  <stdio.h>
#include  <intrinsics.h>

#include  "cry1602.h"
#include  "Cry1602.c"
#include  "SROM.c"
#include  "HMC5983.c"
#include  "ADNS9500.c"
#include  "12864.c"

#define uint unsigned int
#define uchar unsigned char

uchar shuzi[] = {"0123456789"};
uchar zimu[] = {"ABCDEFGHIGKLMNOPQRSTUVWXYZ"};
uchar display[2] = {"aa"}; 
uchar test[3] = {0x4f,0x80,0xf9};
uchar receive[3];

double HMC_Value_Standard;//
double HMC_Value;
double Delta_Angle;
double Motion_X;
double Motion_Y;

/*******************************************
函数名称：DisplayDeal
功    能：将要显示的一个字节的数据转换为可让液晶显示的16进制的数据字符
参    数：无
返回值  ：无
********************************************/
void DisplayDeal(uchar num)
{
    uchar temp;
    temp = num / 16;
    if(temp < 10)
      display[0] = shuzi[temp];
    else
      display[0] = zimu[temp-10];
    num = num % 16;
    if(num < 10)
      display[1] = shuzi[num];
    else
      display[1] = zimu[num-10];
}

/*******************************************
函数名称：HMC_ADNS_Port_Initial
功    能：对电子罗盘和ADNS9500进行端口初始化
参    数：无
返回值  ：无
********************************************/
void HMC_ADNS_Port_Initial()
{
    P5SEL = 0x00;//I/O FUNCTION 
    P5DIR = 0x00;//INPUT
    //HMC_5983
    P5DIR |= BIT6;//P5.6 == SCL
    P5DIR |= BIT7;//P5.7== SDA 
    //ADNS_9500 
    P5DIR |= BIT0;//P5.0 == NCS OUTPUT
    P5DIR |= BIT1;//P5.1==SIMO OUTPUT
    P5DIR &= ~BIT2;//P5.2==SOMI INPUT
    P5DIR |= BIT3;//P5.3==SCLK OUTPUT 
    
    Single_Write_HMC5883(0x02,0x00);  //HMC
    
    Power_Up();//ADNS_9500
    Load_Configuration1();//set cpi
    Set_Observation();//clear
}

/*******************************************
函数名称：main
功    能：主函数
参    数：无
返回值  ：无
********************************************/
void main( void )
{
    uint i;
    int Start_X = 64;
    int Start_Y = 32;
    int End_X;
    int End_Y;
    double Remain_X = 0;
    double Remain_Y = 0;
    int remain_x;
    int remain_y;

    //关闭看门狗
    WDTCTL = WDTPW + WDTHOLD;   
    //将上电默认的800KHz的MCLK时钟设置为外部高频晶振8M
    BCSCTL1 &= ~XT2OFF;
    do
    {
        IFG1 &= ~OFIFG;
        for(i=0xff;i>0;i--);
    }
    while((IFG1 & OFIFG));
    BCSCTL2 |= SELM_2;
  
    //下面六行程序关闭所有的IO口
    P1DIR = 0XFF;P1OUT = 0XFF;//output high
    P2DIR = 0XFF;P2OUT = 0XFF;
    P3DIR = 0XFF;P3OUT = 0XFF;
    P4DIR = 0XFF;P4OUT = 0XFF;
    P5DIR = 0XFF;P5OUT = 0XFF;
    P6DIR = 0XFF;P6OUT = 0XFF;

    HMC_ADNS_Port_Initial();  
//////////////////////////LCD12864/////////////////////////

    Ini_Lcd(); 
    Write_Cmd(0x01);//clear    
    Delay_Nms(10);
    GUI_Fill_GDRAM(0x00);//clear screen
    Delay_Nms(5);
    GUI_Point(64,32,1);
    
//////////////////////data deal///////////////////////
    Multiple_Read_HMC5883();      //连续读出数据，存储在BUF中    
    HMC_Value_Standard = Angle_Deal();//确定角度的标准
    
    while(1)
    {
      
        Infor_Read();//ADNS-9500 
        Motion_Deal();
        
        Multiple_Read_HMC5883();      //连续读出数据，存储在BUF中
        HMC_Value = Angle_Deal();
        
        Delta_Angle = ((HMC_Value - HMC_Value_Standard)/360)*3.14159;//delta angle
        
        HMC_Value_Standard = HMC_Value;//for next
        
        Motion_X = (X * cos(Delta_Angle) - Y * sin(Delta_Angle)) / 198.43;//uint is cm
        Motion_Y = (X * sin(Delta_Angle) + Y * cos(Delta_Angle)) / 198.43;
       
        remain_x = Motion_X;//取整
        remain_y = Motion_Y;
        
        if(Remain_X>1||Remain_X<-1)
        {
            if(Remain_X>1)
                Remain_X = Remain_X-1;
            else
                Remain_X = Remain_X+1;
        }
        else
            Remain_X = Remain_X + Motion_X - remain_x;
            
        if(Remain_Y>1||Remain_Y<-1)
        {
            if(Remain_Y>1)
                Remain_Y = Remain_Y - 1;
            else
                Remain_Y = Remain_Y + 1;
        }
        else
            Remain_Y = Remain_Y + Motion_Y - remain_y;
        
        
        End_X = Start_X + Motion_X + 0.5;//四舍五入 
        End_Y = Start_Y + Motion_Y + 0.5;//四舍五入
        
        ////////////display deal////////////
        Draw_Any_Line(Start_X,Start_Y,End_X,End_Y,1);//start x,y,end x,y,color
        Start_X = End_X;
        Start_Y = End_Y;
        Delayms(200);   
    }
}







































/*******************************************
程序功能：ADNS-9500相关程序
********************************************/

#include  <msp430x14x.h>

#define uint unsigned int
#define uchar unsigned char

#define NCS_ON P5OUT &= ~BIT0  //P5.0==NCS
#define NCS_OFF P5OUT |= BIT0
#define SCLK_UP P5OUT |= BIT3
#define SCLK_DOWN P5OUT &= ~BIT3

#define Motion              Motion_Burst_Read_Buf[0]
#define Observation         Motion_Burst_Read_Buf[1] 
#define Delta_X_L           Motion_Burst_Read_Buf[2]
#define Delta_X_H           Motion_Burst_Read_Buf[3]
#define Delta_Y_L           Motion_Burst_Read_Buf[4]
#define Delta_Y_H           Motion_Burst_Read_Buf[5]
#define SQUAL               Motion_Burst_Read_Buf[6]
#define Pixel_Sum           Motion_Burst_Read_Buf[7]
#define Maximum_Pixel       Motion_Burst_Read_Buf[8]
#define Minimum_Pixel       Motion_Burst_Read_Buf[9]
#define Shutter_Upper       Motion_Burst_Read_Buf[10]
#define Shutter_Lower       Motion_Burst_Read_Buf[11]
#define Frame_Period_Upper  Motion_Burst_Read_Buf[12]
#define Frame_Period_Lower  Motion_Burst_Read_Buf[13]

uchar Motion_Burst_Read_Buf[14] = {0x00};//restore Motion burst read 14 bytes
uchar Powerup_step5[5] = {0xff};//restore 0x02-0x06 5 bytes
uchar CRC_16[2] = {0x00};//for CRC 0: upper, 1: lower
uchar First_Pixel_Check;
uchar PID = 0xff,VID = 0xff;
uchar SROM_ID;
uchar OBS;
uchar LOP;
uchar Squal;
uchar Infor_Buf[5];

int X,Y;
uchar Flag_X,Flag_Y;

/*******************************************
函数名称：Delayus
功    能：延时N个1us的时间
参    数：n--延时长度
返回值  ：无
********************************************/
void Delayus(uint x)//accurate 1.25*x + 0.25 us
{ 
    uint i,j;
    for(j=x;j>0;j--)
       for(i=3;i>0;i--);
}

/*******************************************
函数名称：Delayms
功    能：延时N个1ms的时间
参    数：n--延时长度
返回值  ：无
********************************************/
void Delayms(uint x)
{
    uint i,j,k;
    for(k=x;k>0;k--)//1.25*x 
      for(j=640;j>0;j--)
        for(i=3;i>0;i--);
}

/*******************************************
函数名称：SPI_Port_Initial
功    能：SPI串口初始化
参    数：无
返回值  ：无
********************************************/
void SPI_Port_Initial()
{
    P5SEL = 0x00;   //I/O FUNCTION 
    P5DIR = 0x00;   //INPUT
    P5DIR |= BIT0;  //P5.0 == NCS OUTPUT
    P5DIR |= BIT1;  //P5.1==SIMO OUTPUT
    P5DIR &= ~BIT2; //P5.2==SOMI INPUT
    P5DIR |= BIT3;  //P5.3==SCLK OUTPUT 
}

/*******************************************
函数名称：SPI_Read_One_Data
功    能：读某个地址的一个字节
参    数：一个字节的地址，针对某一个寄存器的地址
返回值  ：一个字节的数据
********************************************/
uchar SPI_Read_One_Data(uchar addr)//SCLK should be UP before used ,after used the SCLK is UP
{
    uchar data = 0;
    uchar data_buf;
    int i;
    
    addr = (addr&0x7f);//msb is 0
    for(i=0;i<8;i++)
    {
        SCLK_DOWN;//
        if(addr&BIT7)
            P5OUT |= BIT1;//msb = 1
        else
            P5OUT &= ~BIT1;//MSB =0
        Delayus(1);//t-setup
        SCLK_UP;//read at rising edge
        Delayus(1);//t-hold
        addr <<= 1;
    }//end of send addr
    
    Delayus(100);//t-SRAD
    
    for(i=0;i<8;i++)
    {
        SCLK_DOWN;//ANDS9500 send    
        if(P5IN&BIT2)//p3.2
          data_buf = 0x01;
        else
          data_buf = 0x00;
        SCLK_UP;
        Delayus(1);//t-hold
        data <<= 1;
        data = (data|data_buf);
    } //end of receive data
    return data;
}

/*******************************************
函数名称：SPI_Write_Addr_Data
功    能：向一个地址，写一个字节
参    数：地址，待发送的数据
返回值  ：无
********************************************/
void SPI_Write_Addr_Data(uchar addr, uchar data)
{
    uint i;
    
    addr = (addr|0x80);//for data write, msb is 1 
    for(i=0;i<8;i++)
    {
        SCLK_DOWN;
        if(addr&BIT7)
            P5OUT |= BIT1;//msb = 1
        else
            P5OUT &= ~BIT1;//MSB =0
        Delayus(1);//t-setup
        SCLK_UP;//read at rising edge
        Delayus(1);//t-hold
        addr <<= 1;
    }//end of send addr  
    
    for(i=0;i<8;i++)
    {
        SCLK_DOWN;
        if(data&BIT7)
            P5OUT |= BIT1;//msb = 1
        else
            P5OUT &= ~BIT1;//MSB =0
        Delayus(1);//t-setup
        SCLK_UP;//read at rising edge
        Delayus(1);//t-hold
        data <<= 1;
    }//end of send data
}

/*******************************************
函数名称：Burst_Mode_2_SROM_Download
功    能：采用Burst方式连续写，进行SROM下载
          将3070个字节的固件数据写入芯片
参    数：无
返回值  ：无
********************************************/
void Burst_Mode_2_SROM_Download()
{
    uint i,j;
    uchar addr,data;
    
    addr = (0x62|0x80);//for data write, msb is 1 
    for(i=0;i<8;i++)
    {
        SCLK_DOWN;
        if(addr&BIT7)
            P5OUT |= BIT1;//msb = 1
        else
            P5OUT &= ~BIT1;//MSB =0
        Delayus(1);//t-setup
        SCLK_UP;//read at rising edge
        Delayus(1);//t-hold
        addr <<= 1;
    }//end of send addr 
    Delayus(15);
    //send 3070 bytes
    for(j=0;j<3070;j++)
    {
        data = adns9500_srom_text_file[j];
        for(i=0;i<8;i++)
        {
            SCLK_DOWN;
            if(data&BIT7)
                P5OUT |= BIT1;//msb = 1
            else
                P5OUT &= ~BIT1;//MSB =0
            Delayus(1);//t-setup
            SCLK_UP;//read at rising edge
            Delayus(1);//t-hold
            data <<= 1;
        } 
        Delayus(15);  
    }
    NCS_OFF;//exit burst mode
    Delayus(4);//tBEXIT 500ns
}

/*******************************************
函数名称：Test_SROM_CRC
功    能：SROM下载完成后进行校验，是否成功
参    数：无
返回值  ：无
********************************************/
void Test_SROM_CRC()//restored in CRC_16[]
{
    NCS_ON;
    Delayus(20);
    SCLK_UP;

    SROM_ID = SPI_Read_One_Data(0x2a);//SROM ID read;        
    Delayus(20);
    
    //step1 == Write 0x15 to SROM_Enable reg to start SROM CRC test
    SPI_Write_Addr_Data(0x13,0x15);
    //step2 == wait at least 10ms
    Delayms(10);
    //step3 == Read CRC value from Data_Out_Lower and Data_Out_Upper regs
    CRC_16[0] = SPI_Read_One_Data(0x26);//upper 
    Delayus(20);//t-SRR
    CRC_16[1] = SPI_Read_One_Data(0x25);//lower  
}

/*******************************************
函数名称：SROM_Download
功    能：进行SROM下载
参    数：无
返回值  ：无
********************************************/
void SROM_Download()
{
    NCS_ON;
    Delayus(20);
    SCLK_UP;
    
    //step1 == select 3K bytes SROM size at Configuration_IV reg
    SPI_Write_Addr_Data(0x39,0x02);
    Delayus(120);//t-SWW
    //step2 == Write 0x1d to SROM_Enable reg for initializng 0x13
    SPI_Write_Addr_Data(0x13,0x1d);
    //step3 == wait for one frame
    Delayus(1000);
    //step4 == write 0x18 SROM_Enable reg again to start SROM downloading
    SPI_Write_Addr_Data(0x13,0x18);
    Delayus(120);
    //step5 == Star Downloading SROM, and exit Burst mode, off NCS
    Burst_Mode_2_SROM_Download();
  
    Delayus(10);
    NCS_OFF;
    Delayus(1);//t-BEXIT
}

/*******************************************
函数名称：LASER_Output_Power
功    能：驱动激光器
参    数：无
返回值  ：无
********************************************/
void LASER_Output_Power()
{
    LOP = SPI_Read_One_Data(0x20);
    LOP &= 0xf4;//1111 0100
    Delayus(20);//t-SRW
    SPI_Write_Addr_Data(0x20,LOP);    
    Delayus(120);//t-SWW/SWR 
}

/*******************************************
函数名称：Power_Up
功    能：芯片上电序列
参    数：无
返回值  ：无
********************************************/
void Power_Up()
{
    //step1 == apply power
    //step2 == reset SPI
    NCS_OFF;
    Delayus(20);
    NCS_ON;
    Delayus(20);
    //step3 == write 0x5a to Power_Up_Reset(0x3a)
    SCLK_UP;
    SPI_Write_Addr_Data(0x3a,0x5a);
    //step4 == wait at least 50ms
    Delayms(50);
    
    //step5 == read 0x02 0x03 0x04 0x05 0x06
    Powerup_step5[0] = SPI_Read_One_Data(0x02);    
    Delayus(20);//SRR
    Powerup_step5[1] = SPI_Read_One_Data(0x03);    
    Delayus(20);    
    Powerup_step5[2] = SPI_Read_One_Data(0x04);    
    Delayus(20);    
    Powerup_step5[3] = SPI_Read_One_Data(0x05);    
    Delayus(20);  
    Powerup_step5[4] = SPI_Read_One_Data(0x06);    
    Delayus(20); 
    NCS_OFF;
    Delayus(20);
    NCS_ON;
    //step5.1 == PID read and VID read
//    PID = SPI_Read_One_Data(0x00);
//    Delayus(20);//SRR
//    VID = SPI_Read_One_Data(0x01);
    Delayus(20);
    //step6 == SROM download
    SROM_Download();
    //step6.1 == SROM CRC check
    Delayus(150);//soonest >=160
    Test_SROM_CRC();
    //step7 == Enable laser by setting Forced_Disable bit(bit-0)of LASER_CTRL0 register(address 0x20) to 0
    Delayus(20);//SRW
    LASER_Output_Power();//CW1 CW2 CW3, Forced_Disable bit
}

/*******************************************
函数名称：Burst_Mode_1_Motion_Read
功    能：采用Burst方式进行读数据
参    数：无
返回值  ：无
********************************************/
void Burst_Mode_1_Motion_Read()//data restored in Motion_Burst_Read_Buf[i]
{ 
    uint i,j;
    uint data;
    uint data_buf;
    for(j=0;j<14;j++)//clear Receive_Buf[]
    {       
        for(i=0;i<8;i++)
        {
            SCLK_DOWN;//ANDS9500 send    
            if(P5IN&BIT2)//p3.2
              data_buf = 0x01;
            else
              data_buf = 0x00;
            SCLK_UP;
            Delayus(1);//t-hold
            data <<= 1;
            data = (data|data_buf);
        } //end of receive data 
        Motion_Burst_Read_Buf[j] = data;
    }
}

/*******************************************
函数名称：Burst_Motion_Read
功    能：采用Burst方式进行读取Motion等14个字节的数据
参    数：无
返回值  ：无
********************************************/
void Burst_Motion_Read()
{
    //step1 == lower NCS
    NCS_ON;
    //step2 == send 0x50 to Motion_Burst reg 0x50
    SCLK_UP;
    SPI_Write_Addr_Data(0x50,0x50);
    //step3 == wait for one frame
    Delayus(1000);// 
    //step4 == read 14 bytes continusly, end with off NCS for tBEXIT
    Burst_Mode_1_Motion_Read();
    NCS_OFF;//pulling NCS high
    Delayus(1);//t-BEXIT
    
    //step5 == read new data from step1
    //step6 == write any value to Motion Reg to clear residual motion
    SPI_Write_Addr_Data(0x02,0xff); 
    Delayus(120);//t-SWW/SWR
}   

/*******************************************
函数名称：Infor_Read
功    能：采用单个字节读取方式进行读取Motion等14个字节的数据
参    数：无
返回值  ：无
********************************************/
void Infor_Read()
{
    int i;
  
    NCS_ON;
    SCLK_UP;        
    for(i=0;i<5;i++)
    {
        Infor_Buf[i] = SPI_Read_One_Data(0x02+i);
        Delayus(20);//t-SRR/SRW
    }
    Squal = SPI_Read_One_Data(0x07);
    Delayus(20);
    SPI_Write_Addr_Data(0x02,0x00);//write 0x00 to motion to clear
    Delayus(120);//t-SWW/SWR
    
    NCS_OFF;
}

/*******************************************
函数名称：Load_Configuration
功    能：在芯片正常工作前对一些必要的寄存器进行配置
参    数：无
返回值  ：无
********************************************/
void Load_Configuration()
{
    SPI_Write_Addr_Data(0x0f,0x12);//config 1 cpi = 1620
    Delayus(120);//t-SWW/SWR
    
    SPI_Write_Addr_Data(0x10,0x0c);//config 2 Rpt_Mode bit = 1 ,to set Y cpi, &Fixed_FR = 1
    //Fixed Frame rate 1958, frame rate 1958,frame period 0x5dc0,24000
    Delayus(120);//t-SWW/SWR   
    
    SPI_Write_Addr_Data(0x2f,0x12);//config 4 cpi = 1620
    Delayus(120);//t-SWW/SWR
}

/*******************************************
函数名称：Load_Configuration1
功    能：在芯片正常工作前对一些必要的寄存器进行配置
参    数：无
返回值  ：无
********************************************/
void Load_Configuration1()//cpi = 5040
{
    SPI_Write_Addr_Data(0x0f,0x38);//config 1 cpi = 5040
    Delayus(120);//t-SWW/SWR
    
    SPI_Write_Addr_Data(0x10,0x0c);//config 2 Rpt_Mode bit = 1 ,to set Y cpi, &Fixed_FR = 1
    //Fixed Frame rate 1958, frame rate 1958,frame period 0x5dc0,24000
    Delayus(120);//t-SWW/SWR   
    
    SPI_Write_Addr_Data(0x2f,0x38);//config 4 cpi = 5040
    Delayus(120);//t-SWW/SWR
}

/*******************************************
函数名称：Set_Observation
功    能：在芯片正常工作前对observation寄存器进行配置
参    数：无
返回值  ：无
********************************************/
void Set_Observation()
{
    // Clear observation register
    SPI_Write_Addr_Data(0x24,0x00);
    Delayus(20);//t-SRR/SRW
}


/*******************************************
函数名称：Motion_Deal
功    能：将读取的数据进行处理,并进行补码转换
参    数：无
返回值  ：无
********************************************/
void Motion_Deal()
{
    X = Infor_Buf[2] << 8 | Infor_Buf[1]; //Combine MSB and LSB of X Data output register
    Y = Infor_Buf[4] << 8 | Infor_Buf[3]; //Combine MSB and LSB of Z Data output register
}






/*******************************************
程序功能：HMC5983相关程序
********************************************/
#include  <msp430x14x.h>

#define SCL_H P5OUT |= BIT6
#define SCL_L P5OUT &= ~BIT6
#define SDA_H P5OUT |= BIT7
#define SDA_L P5OUT &= ~BIT7

#define SDA_in  P5DIR &= ~BIT7   //SDA改成输入模式
#define SDA_out P5DIR |= BIT7    //SDA变回输出模式
#define SDA_val P5IN&BIT7        //SDA的位值
 
#define TRUE    1
#define FALSE   0

#define	SlaveAddress   0x3C	  //定义器件在IIC总线中的从地址

uchar NUM[10]={"0123456789"};
uchar ge,shi,bai,qian,wan;           //显示变量
uchar BUF[8];

//double HMC_Value;
/***********************************************
函数名称：Delay1us
功    能：延时1us
参    数：x的值代表延时Nus
返回值  无
***********************************************/
void Delay1us(uint x)//accurate 1.25*x + 0.25 us
{ 
    uint i,j;
    for(j=x;j>0;j--)
       for(i=3;i>0;i--);
}

/***********************************************
函数名称：conversion
功    能：将数据转化为能让液晶屏显示的单个字符
参    数：要转换的数据
返回值  无
***********************************************/
void conversion(uint temp_data)  
{  
    wan=temp_data/10000 + 0x30;
    
    temp_data=temp_data%10000;   //取余运算
    qian=temp_data/1000 + 0x30;
    
    temp_data=temp_data%1000;    //取余运算
    bai=temp_data/100 + 0x30;
    
    temp_data=temp_data%100;     //取余运算
    shi=temp_data/10 + 0x30;
    
    temp_data=temp_data%10;      //取余运算
    ge=temp_data + 0x30; 	
}


/***********************************************
函数名称：HMC5883_Start
功    能：起始信号
参    数：无
返回值  无
***********************************************/
void HMC5883_Start()
{
    SDA_H;                    //拉高数据线
    SCL_H;                    //拉高时钟线
    Delay1us(5);              //延时
    SDA_L;                    //产生下降沿
    Delay1us(5);              //延时
    SCL_L;                    //拉低时钟线
}

/***********************************************
函数名称：HMC5883_Stop
功    能：停止信号
参    数：无
返回值  无
***********************************************/
void HMC5883_Stop()
{
    SDA_L;                    //拉低数据线
    SCL_H;                    //拉高时钟线
    Delay1us(5);                 //延时
    SDA_H;                    //产生上升沿
    Delay1us(5);                 //延时
}

/***********************************************
函数名称：HMC5883_SendACK1
功    能：发送应答信号
参    数：ack (0:ACK 1:NAK)
返回值  无
***********************************************/
void HMC5883_SendACK1()
{
    SDA_H;                  //写应答信号
    SCL_H;                    //拉高时钟线
    Delay1us(5);                 //延时
    SCL_L;                    //拉低时钟线
    Delay1us(5);                 //延时
}

/***********************************************
函数名称：HMC5883_SendACK0
功    能：发送应答信号
参    数：ack (0:ACK 1:NAK)
返回值  无
***********************************************/
void HMC5883_SendACK0()
{
    SDA_L;                  //写应答信号
    SCL_H;                    //拉高时钟线
    Delay1us(5);                 //延时
    SCL_L;                    //拉低时钟线
    Delay1us(5);                 //延时
}

/***********************************************
函数名称：HMC5883_RecvACK()
功    能：接收应答信号
参    数：无
返回值  无
***********************************************/
uchar HMC5883_RecvACK()
{
    uchar a;   
    SDA_in;
    
    SCL_H;                    //拉高时钟线
    Delay1us(5);                 //延时
    
    a = SDA_val;                 //读应答信号
    SCL_L;                    //拉低时钟线
    Delay1us(5);                 //延时
    SDA_out;

    return a;
}

/***********************************************
函数名称：HMC5883_SendByte
功    能：向IIC总线发送一个字节数据
参    数：待发送的数据，一个字节
返回值  无
***********************************************/
void HMC5883_SendByte(uchar dat)
{
    uchar i;

    for(i = 0;i < 8;i++)//8位计数器
    {
      
       if(dat & 0x80)//1
            SDA_H;            
        else 			    
            SDA_L;
        SCL_H;
        Delay1us(5);
        SCL_L;
        Delay1us(5);
        dat <<= 1;
    }    
    HMC5883_RecvACK();
}

/***********************************************
函数名称：HMC5883_RecvByt
功    能：从IIC总线接收一个字节数据
参    数：无
返回值  接收到的一个字节的数据
***********************************************/
uchar HMC5883_RecvByte()
{
    uchar  rdata = 0x00,i;
    uchar flag;
    
    SDA_H;
    for(i = 0;i < 8;i++)
    {
            SCL_H;
    SDA_in;
            Delay1us(5);
            flag = SDA_val;
            rdata <<= 1;
            if(flag)	
                rdata |= 0x01;
    SDA_out;
            SCL_L;
            Delay1us(5);
    }
    return rdata;
}


/***********************************************
函数名称：Single_Write_HMC5883
功    能：向某一个寄存器发送一个字节的数据
参    数：uchar REG_Address：寄存器地址
          uchar REG_data：待发送的数据
返回值  无
***********************************************/
void Single_Write_HMC5883(uchar REG_Address,uchar REG_data)
{
    HMC5883_Start();                  //起始信号
    HMC5883_SendByte(SlaveAddress);   //发送设备地址+写信号
    HMC5883_SendByte(REG_Address);    //内部寄存器地址，请参考中文pdf 
    HMC5883_SendByte(REG_data);       //内部寄存器数据，请参考中文pdf
    HMC5883_Stop();                   //发送停止信号
}

/***********************************************
函数名称：Single_Read_HMC5883
功    能：单字节读取内部寄存器
参    数：寄存器地址
返回值  ：一个字节的数据
***********************************************/
uchar Single_Read_HMC5883(uchar REG_Address)
{  
    uchar REG_data;
    HMC5883_Start();                  //起始信号
    HMC5883_SendByte(SlaveAddress);   //发送设备地址+写信号
    HMC5883_SendByte(REG_Address);    //发送存储单元地址，从0开始	
    HMC5883_Start();                  //起始信号
    HMC5883_SendByte(SlaveAddress+1); //发送设备地址+读信号
    REG_data = HMC5883_RecvByte();    //读出寄存器数据
    HMC5883_SendACK1();   
    HMC5883_Stop();                   //停止信号
    return REG_data; 
}

/***********************************************
函数名称：Multiple_Read_HMC5883
功    能：连续读出HMC5883内部角度数据，地址范围0x3~0x5
参    数：无
返回值  ：无
***********************************************/
void Multiple_Read_HMC5883(void)
{   uchar i;
    HMC5883_Start();                  //起始信号
    HMC5883_SendByte(SlaveAddress);   //发送设备地址+写信号
    HMC5883_SendByte(0x03);           //发送存储单元地址，从0x3开始	
    HMC5883_Start();                  //起始信号
    HMC5883_SendByte(SlaveAddress+1); //发送设备地址+读信号
    for (i=0; i<6; i++)               //连续读取6个地址数据，存储中BUF
    {
        BUF[i] = HMC5883_RecvByte();  //BUF[0]存储数据
        if (i == 5)
        {
           HMC5883_SendACK1();        //最后一个数据需要回NOACK
        }
        else
        {
          HMC5883_SendACK0();         //回应ACK
       }
   }
    HMC5883_Stop();                   //停止信号
    Delay1us(5000);
}

/***********************************************
函数名称：Init_HMC5883
功    能：初始化HMC5883
参    数：无
返回值  ：无
***********************************************/
void Init_HMC5883()
{
      //HMC5983 Initial
     P5SEL = 0x00;//I/O FUNCTION 
     P5DIR = 0x00;//INPUT
     P5DIR |= BIT6;//P5.0 == NCS OUTPUT
     P5DIR |= BIT7;//P5.1==SIMO OUTPUT 
     
     Single_Write_HMC5883(0x02,0x00);  //
}


/***********************************************
函数名称：Angle_Deal()
功    能：分别读取X轴、Y轴、Z轴的值，并对数据进行处理让主函数使用
参    数：无
返回值  ：黄精度型的角度值
***********************************************/
double Angle_Deal()//return to Angle[]
{
    int x,y,z;
    double angle;  
    
    x = BUF[0] << 8 | BUF[1]; //Combine MSB and LSB of X Data output register
    z = BUF[2] << 8 | BUF[3]; //Combine MSB and LSB of Z Data output register
    y = BUF[4] << 8 | BUF[5]; //Combine MSB and LSB of Y Data output register
    angle = atan2((double)y,(double)x) * (180 / 3.14159265) + 180; // angle in degrees
    
//    HMC_Value = angle;//for main to deal
    
    angle *= 10;    
    conversion(angle);       //计算数据和显示
    return (angle/10);
}



/***********************************************
程序功能：12864LCD相关程序
***********************************************/

#include  <msp430x14x.h>

#define uint unsigned int
#define uchar unsigned char

uchar shuzi_table[] = {"0123456789"};

#define LCD_DataIn    P4DIR=0x00    //数据口方向设置为输入
#define LCD_DataOut   P4DIR=0xff    //数据口方向设置为输出
#define LCD2MCU_Data  P4IN
#define MCU2LCD_Data  P4OUT
#define LCD_CMDOut    P3DIR|=0x07     //P3口的低三位设置为输出
#define LCD_RS_H      P3OUT|=BIT0      //P3.0
#define LCD_RS_L      P3OUT&=~BIT0     //P3.0
#define LCD_RW_H      P3OUT|=BIT1      //P3.1
#define LCD_RW_L      P3OUT&=~BIT1     //P3.1
#define LCD_EN_H      P3OUT|=BIT2      //P3.2
#define LCD_EN_L      P3OUT&=~BIT2     //P3.2

/*******************************************
函数名称：Delay_1ms
功    能：延时约1ms的时间
参    数：无
返回值  ：无
********************************************/
void Delay_1ms(void)
{
    uint i,j;
    for(j=640;j>0;j--)
      for(i=3;i>0;i--);
} 
/*******************************************
函数名称：Delay_Nms
功    能：延时N个1ms的时间
参    数：n--延时长度
返回值  ：无
********************************************/
void Delay_Nms(uint n)
{
    uint i;
    
    for(i = n;i > 0;i--)    
        Delay_1ms();
}
/*******************************************
函数名称：Write_Cmd
功    能：向液晶中写控制命令
参    数：cmd--控制命令
返回值  ：无
********************************************/
void Write_Cmd(uchar cmd)
{
    uchar lcdtemp = 0;
			
    LCD_RS_L;
    LCD_RW_H;
    LCD_DataIn;  
    do                       //判忙
    {    
        LCD_EN_H;
       	_NOP();					
       	lcdtemp = LCD2MCU_Data; 
       	LCD_EN_L;
        
    }
    while(lcdtemp & 0x80); 
    
    LCD_DataOut;    
    LCD_RW_L;  		
    MCU2LCD_Data = cmd; 
    LCD_EN_H;
    _NOP();						  			
    LCD_EN_L;
}
/*******************************************
函数名称：Write_Data
功    能：向液晶中写显示数据
参    数：dat--显示数据
返回值  ：无
********************************************/
void  Write_Data(uchar dat)
{
    uchar lcdtemp = 0;   
        
    LCD_RS_L;
    LCD_RW_H;  
    LCD_DataIn;   
    do                       //判忙
    {    
        LCD_EN_H;
        _NOP();						
        lcdtemp = LCD2MCU_Data; 
        LCD_EN_L;      
    }
    while(lcdtemp & 0x80);  
    
    LCD_DataOut; 
    LCD_RS_H;
    LCD_RW_L;  
        
    MCU2LCD_Data = dat;
    LCD_EN_H;
    _NOP();
    LCD_EN_L;
} 


/*******************************************
函数名称：Read_Data
功    能：从液晶中读显示数据
参    数：
返回值  ：一个字节
********************************************/
uchar Read_Data()
{
    uchar temp;
    LCD_DataOut;//release data wire
    MCU2LCD_Data |= 0xff;
    LCD_RS_H;
    LCD_RW_H;
    LCD_DataIn;
    LCD_EN_H;
    Delay_1ms();
    
    temp=LCD2MCU_Data;
    Delay_1ms();
    LCD_EN_L;
    return temp;    
}

/*******************************************
函数名称：Ini_Lcd
功    能：初始化液晶模块
参    数：无
返回值  ：无
********************************************/
void Ini_Lcd(void)
{                  
    LCD_CMDOut;    //液晶控制端口设置为输出
    
    Delay_Nms(500);
    Write_Cmd(0x30);   //基本指令集
    Delay_1ms();
    Write_Cmd(0x02);   // 地址归位
    Delay_1ms();
    Write_Cmd(0x0c);   //整体显示打开,游标关闭
    Delay_1ms();
    Write_Cmd(0x01);   //清除显示
    Delay_1ms();
    Write_Cmd(0x06);   //游标右移
    Delay_1ms();
    Write_Cmd(0x80);   //设定显示的起始地址
}
/*******************************************
函数名称：Disp_HZ
功    能：控制液晶显示汉字
参    数：addr--显示位置的首地址
          pt--指向显示数据的指针
          num--显示字符个数
返回值  ：无
********************************************/
void Disp_HZ(uchar addr,const uchar * pt,uchar num)
{
    uchar i;
		
    Write_Cmd(addr); 
    for(i = 0;i < (num*2);i++) 
    Write_Data(*(pt++)); 
} 

void Disp_String(unsigned char x,unsigned char y,unsigned char *Str)
{  
    uchar pos;
    if((y>4)||(x>8)) 
        return;
    if(x==1){x=0x80;}
    else if(x==2){x=0x90;}
        else if(x==3){x=0x88;}
    else if(x==4){x=0x98;}
    pos=x+y;
    Write_Cmd(pos);

    while(*Str>0)
    { Write_Data(*Str); Str++;}
}

/*******************************************
函数名称:Clear_GDRAM
功    能:清除液晶GDRAM中的随机数据
参    数:无
返回值  :无
********************************************/
void Clear_GDRAM(void)
{
    uchar i,j,k;
    
    Write_Cmd(0x34);        //打开扩展指令集
    i = 0x80;            
    for(j = 0;j < 32;j++)
    {
    Write_Cmd(i++);
    Write_Cmd(0x80);
        for(k = 0;k < 16;k++)
        {
            Write_Data(0x00);
        }
    }
    i = 0x80;
    for(j = 0;j < 32;j++)
    {
        Write_Cmd(i++);
        Write_Cmd(0x88);	   
        for(k = 0;k < 16;k++)
        {
            Write_Data(0x00);
        } 
    }   
    Write_Cmd(0x30);        //回到基本指令集
}
/*******************************************
函数名称:Draw_PM
功    能:在整个液晶屏幕上画图
参    数:无
返回值  :无
********************************************/
void Draw_PM(const uchar *ptr)
{
    uchar i,j,k;
    
    Write_Cmd(0x34);        //打开扩展指令集
    i = 0x80;            
    for(j = 0;j < 32;j++)
    {
        Write_Cmd(i++);
        Write_Cmd(0x80);
        for(k = 0;k < 16;k++)
        {
            Write_Data(*ptr++);
        }
    }
    i = 0x80;
    for(j = 0;j < 32;j++)
    {
        Write_Cmd(i++);
        Write_Cmd(0x88);	   
        for(k = 0;k < 16;k++)
        {
            Write_Data(*ptr++);
        } 
    }  
    Write_Cmd(0x36);        //打开绘图显示
    Write_Cmd(0x30);        //回到基本指令集
}
/*******************************************
函数名称：Draw_TX
功    能：显示一个16*16大小的图形
参    数：Yaddr--Y地址
          Xaddr--X地址
          dp--指向图形数据存放地址的指针
返回值  ：无
********************************************/
void Draw_TX(uchar Yaddr,uchar Xaddr,const uchar * dp) 
{
    uchar j;
    uchar k=0;
 
    Write_Cmd(0x01);  //清屏,只能清除DDRAM
    Write_Cmd(0x34);  //使用扩展指令集，关闭绘图显示
    for(j=0;j<16;j++)
    {
        Write_Cmd(Yaddr++);       //Y地址
        Write_Cmd(Xaddr);    //X地址
        Write_Data(dp[k++]);  
        Write_Data(dp[k++]);
    }
    Write_Cmd(0x36);  //打开绘图显示
    Write_Cmd(0x30);  //回到基本指令集模式
}

//********************************************//
//函数名称：Draw_Point
//功    能：给定坐标并打点
//参    数：x:坐标(0~127)
//          y:坐标(0~63)
//参    数：color=1，该点显示；color=0，该点清除；
//********************************************************//
void GUI_Point(uchar x,uchar y,uchar color)
{
    uchar x_Dyte,x_byte; //定义列地址的字节位，及在字节中的哪1 位
    uchar y_Dyte,y_byte; //定义为上下两个屏(取值为0，1)，行地址(取值为0~31)
    uchar GDRAM_hbit,GDRAM_lbit;
    Write_Cmd(0x36); //扩展指令命令;
  /***X,Y 坐标互换，即普通的X,Y 坐标***/
    x_Dyte=x/16; //计算在16 个字节中的哪一个
    x_byte=x%16; //计算在该字节中的哪一位
    y_Dyte=y/32; //0 为上半屏，1 为下半屏
    y_byte=y%32; //计算在0~31 当中的哪一行
    Write_Cmd(0x80+y_byte); //设定行地址(y 坐标),即是垂直地址
    Write_Cmd(0x80+x_Dyte+8*y_Dyte); //设定列地址(x 坐标)，并通过8*y_Dyte 选定上下屏，即是水平地址
    Read_Data(); //预读取数据
    GDRAM_hbit=Read_Data(); //读取当前显示高8 位数据
    GDRAM_lbit=Read_Data(); //读取当前显示低8 位数据
    //read operation will change AC, reset
    Write_Cmd(0x80+y_byte); //设定行地址(y 坐标)
    Write_Cmd(0x80+x_Dyte+8*y_Dyte); //设定列地址(x 坐标)，并通过8*y_Dyte 选定上下屏
    if(x_byte<8) //判断其在高8 位，还是在低8 位
    {
         if(color==1)
             Write_Data(GDRAM_hbit|(0x01<<(7-x_byte))); //置位GDRAM 区高8 位数据中相应的点
         else
             Write_Data(GDRAM_hbit&(~(0x01<<(7-x_byte)))); //清除GDRAM 区高8 位数据中相应的点
         
         Write_Data(GDRAM_lbit); //显示GDRAM 区低8 位数据
    }
    else
    {
         Write_Data(GDRAM_hbit);         //写高8位数据
         if(color==1)
             Write_Data(GDRAM_lbit|(0x01<<(15-x_byte))); //置位GDRAM 区高8 位数据中相应的点
         else
             Write_Data(GDRAM_lbit&(~(0x01<<(15-x_byte))));//清除GDRAM区高8位数据中相应的点
    }
    Write_Cmd(0x30); //恢复到基本指令集
}

//********************************************************
//填充GDRAM 数据：
//参数：dat 为填充的数据
//dat为0x00可以作为清屏作用
//********************************************************
void GUI_Fill_GDRAM(unsigned char dat)
{
    uchar i,j,k;
    
    uchar bGDRAMAddrX = 0x80; //GDRAM 水平地址
    uchar bGDRAMAddrY = 0x80; //GDRAM 垂直地址
    for(i=0;i<2;i++)//上半屏
    {
        for(j=0;j<32;j++)//半屏32行
            for(k=0;k<8;k++)//8列
            {
                Write_Cmd(0x34); //设置为8 位MPU 接口，扩充指令集,绘图模式关
                Write_Cmd(bGDRAMAddrY+j); //垂直地址Y
                Write_Cmd(bGDRAMAddrX+k); //水平地址X
                Write_Data(dat);//D15-D8
                Write_Data(dat);//D7-D0
            }
        bGDRAMAddrX = 0x88;//下半屏
    }
    Write_Cmd(0x36); //打开绘图模式
    Write_Cmd(0x30); //恢复基本指令集，关闭绘图模式
}

//***********************************************//
//******************画水平线*********************//
//***********************************************//
void LCD_Draw_Line_X( uchar X0, uchar X1, uchar Y, uchar Color )
{   
    uchar Temp ;
    if( X0 > X1 )
    {
        Temp = X1 ;
        X1 = X0 ;
        X0 = Temp ;
    }
    for( ; X0 <= X1 ; X0++ )
    GUI_Point( X0, Y, Color );    
}

//***********************************************//
//画垂直线  第x列  从第y0行画到第y1行  颜色 color
//***********************************************//
void LCD_Draw_Line_Y( uchar X, uchar Y0, uchar Y1, uchar Color )
{
    uchar Temp ;
    if( Y0 > Y1 )
    {
        Temp = Y1 ;
        Y1 = Y0 ;
        Y0 = Temp ;
    }
    for(; Y0 <= Y1 ; Y0++)
    GUI_Point( X, Y0, Color);
}

//***********************************************//
//函数功能：画斜线(x,y)到(end x,end y)
//***********************************************//
void LCD_Draw_Line( uchar StartX, uchar StartY, uchar EndX, uchar EndY, uchar Color )
{
    int distance;      /*根据屏幕大小改变变量类型(如改为int型)*/
    int delta_x, delta_y ;
    int incx, incy ;
    do
    {
        delta_x = EndX - StartX ;
        delta_y = EndY - StartY ;
        //delta x
        if( delta_x > 0 )
            incx = 1;        
        else 
        {
            if( delta_x == 0 )
                incx = 0;
            else
                incx = -1 ;
        }
        //delta y
        if( delta_y > 0 )
            incy = 1 ;
        else 
        {
            if(delta_y == 0 )
                incy = 0 ;
            else
                incy = -1 ;
        }
        delta_x = incx * delta_x ;//jue dui zhi    
        delta_y = incy * delta_y ;
    
        if( delta_x > delta_y )
        {
            distance = delta_x ;
            StartX+=incx;
            StartY+=incy;
        }
       else
       {
           distance = delta_y;
           StartX+=incx;
           StartY+=incy;
       }
       GUI_Point( StartX, StartY, Color ); 
    }
    while(distance!=0);
}

//***********************************************//
//函数功能：画  sin函数曲线
//***********************************************//
void fsin2()
{
    float x,y;
    uchar x1,y1;
    for(x=0;x<(4*3.14159);x+=0.1)
    {
        y=1*sin(3*x);
        x1=10*x;
        y1=31-(10*y+0.5);			  //对y值进行四舍五入
        GUI_Point(x1,y1,1);
    }
}  

//****************************************//
//        画圆
//*****************************************//
void GUI_Circle(uchar x0,uchar y0,uchar r,uchar color)
{  
    signed char a,b;
    signed char di;
    if(r>31 ||r==0) 
        return; //参数过滤，次液晶显示的最大圆半径为31
    a=0;
    b=r;
    di=3-2*r; //判断下个点位置的标志
    while(a<=b)
    {
        GUI_Point(x0-b,y0-a,color); //3
        GUI_Point(x0+b,y0-a,color); //0
        GUI_Point(x0-a,y0+b,color); //1
        GUI_Point(x0-b,y0-a,color); //7
        GUI_Point(x0-a,y0-b,color); //2
        GUI_Point(x0+b,y0+a,color); //4
        GUI_Point(x0+a,y0-b,color); //5
        GUI_Point(x0+a,y0+b,color); //6
        GUI_Point(x0-b,y0+a,color);
        a++;
      /***使用Bresenham 算法画圆**/
        if(di<0)
            di +=4*a+6;
        else
        {
            di +=10+4*(a-b);
            b--;
        }
        GUI_Point(x0+a,y0+b,color);
    }
}
//***********************************************//
//函数功能：画  任意角度的直线
//***********************************************//
void Draw_Any_Line( unsigned char StartX, unsigned char StartY, unsigned char EndX, unsigned char EndY, unsigned char Color )
{
    int t, distance;      
    int x = 0 , y = 0 , delta_x, delta_y ;
    signed char incx, incy ;

    delta_x = EndX - StartX ;
    delta_y = EndY - StartY ;

    if( delta_x > 0 )
        incx = 1;
    else 
    {
        if( delta_x == 0 )
        {
            LCD_Draw_Line_Y( StartX, StartY, EndY,Color );
            return ;
        }
        else
            incx = -1 ;
    }
    
    if( delta_y > 0 )
        incy = 1 ;
    else 
    {
        if(delta_y == 0 )
        {
            LCD_Draw_Line_X( StartX, EndX, StartY, Color );
            return ;
        }
        else
            incy = -1 ;
    }

    delta_x = abs( delta_x );   
    delta_y = abs( delta_y );
    
    if( delta_x > delta_y )
        distance = delta_x ;
    else
        distance = delta_y ;
    
    GUI_Point( StartX, StartY, Color );  
   
    for( t = 0 ; t <= distance+1  ; t++ )
    {
        GUI_Point( StartX, StartY, Color );
        x += delta_x ;
        y += delta_y ;
        if( x > distance )
        {
            x -= distance ;
            StartX += incx ;
        }
        if( y > distance )
        {
            y -= distance ;
            StartY += incy ;
        }
    }
}








//***********************************************//
//程序功能：SROM固件
//***********************************************//

#include<msp430x14x.h>

const uchar adns9500_srom_text_file[] = 
{
    0x03, 0x91, 0x31, 0xc2, 0xc2, 0xd1, 0x9e, 0xbe,
    0xdf, 0x1c, 0xb8, 0xf2, 0x66, 0x2f, 0xdc, 0x3a,
    0xd7, 0x0d, 0x79, 0x70, 0x4d, 0x07, 0x67, 0x35,
    0xc4, 0x10, 0x83, 0x84, 0x6b, 0x54, 0x0b, 0x75,
    0x68, 0x33, 0xe4, 0x2b, 0xd4, 0x2a, 0xb1, 0xca,
    0x10, 0xbb, 0xc2, 0xed, 0x39, 0xd1, 0x20, 0xa3,
    0xc4, 0xeb, 0x35, 0xc9, 0x10, 0xa6, 0xa7, 0xcc,
    0x1a, 0x97, 0xac, 0xda, 0x3c, 0xcf, 0xf6, 0x78,
    0x53, 0x24, 0xca, 0x16, 0x8f, 0x9c, 0xba, 0xd7,
    0x2c, 0xbb, 0xd5, 0x09, 0x90, 0xa2, 0xc6, 0xef,
    0x3d, 0xf8, 0x53, 0x05, 0x69, 0x50, 0x20, 0x6f,
    0x55, 0xd2, 0x29, 0xd6, 0xee, 0x63, 0x95, 0xae,
    0xc8, 0xd7, 0x95, 0x84, 0x47, 0xc9, 0x27, 0xd0,
    0x11, 0x8a, 0x69, 0x3b, 0x0b, 0xc2, 0x12, 0xef,
    0xa3, 0x42, 0x57, 0xaf, 0xc2, 0x5e, 0x97, 0xa8,
    0xe5, 0x0c, 0x03, 0x74, 0xac, 0x1f, 0x1e, 0xb4,
    0x34, 0x9a, 0x66, 0x62, 0x93, 0x0e, 0x61, 0xc6,
    0xc8, 0x52, 0xe8, 0xce, 0xe1, 0x0a, 0x08, 0x1c,
    0x2a, 0x57, 0x9d, 0x04, 0x01, 0x4c, 0xf7, 0x62,
    0x7e, 0xb3, 0x8f, 0xee, 0xdf, 0xe9, 0xba, 0x06,
    0xfb, 0xf5, 0x9b, 0x63, 0x53, 0xf5, 0x12, 0x06,
    0x71, 0x28, 0x19, 0x44, 0xa9, 0x0b, 0xcf, 0xba,
    0x4c, 0x6a, 0x05, 0xd1, 0x3c, 0x1d, 0x4e, 0x32,
    0x52, 0x9f, 0x4b, 0x89, 0x11, 0x9f, 0x81, 0x54,
    0x62, 0x8f, 0x9a, 0x0f, 0x70, 0x2e, 0xcf, 0x92,
    0x04, 0x9b, 0xc1, 0x35, 0xd8, 0xeb, 0x58, 0x63,
    0x7d, 0x87, 0x86, 0x9d, 0x38, 0x14, 0x60, 0xb3,
    0xd6, 0xa7, 0x92, 0xd8, 0x16, 0x41, 0xf1, 0x42,
    0x50, 0x63, 0x35, 0xcd, 0x8b, 0x03, 0xcc, 0xba,
    0x0b, 0x0f, 0x68, 0x4e, 0xbc, 0x89, 0x62, 0x16,
    0x6c, 0x37, 0x71, 0xe7, 0xa9, 0x82, 0x71, 0xdb,
    0xb6, 0x26, 0xa7, 0xd6, 0x78, 0xbc, 0xc7, 0x34,
    0xbb, 0xcd, 0x2e, 0x7d, 0x78, 0xaf, 0xbe, 0x69,
    0x55, 0xfe, 0xc5, 0xac, 0xfd, 0x30, 0x38, 0x46,
    0xc6, 0x52, 0x1e, 0xef, 0x44, 0x1d, 0xfa, 0x59,
    0xd0, 0x61, 0xf6, 0x3c, 0x00, 0x1f, 0xf2, 0x65,
    0x5a, 0x67, 0xda, 0x52, 0x74, 0xa2, 0x25, 0xcb,
    0xa0, 0xb0, 0xd5, 0x51, 0x3c, 0xcd, 0x63, 0xe5,
    0xbb, 0x43, 0xd0, 0xa8, 0x06, 0x60, 0xb6, 0xf2,
    0xeb, 0x5e, 0x7f, 0x62, 0x0e, 0x74, 0x9e, 0xbb,
    0x00, 0x3d, 0x6d, 0x8b, 0x61, 0x5e, 0xa5, 0x93,
    0x01, 0x5d, 0xc4, 0xfa, 0xf7, 0x45, 0xb4, 0xc4,
    0x42, 0xee, 0x2a, 0x7d, 0x2d, 0x08, 0x17, 0xc7,
    0x6e, 0x1e, 0x76, 0x48, 0xea, 0xf2, 0x7c, 0x53,
    0xc4, 0x5b, 0x0c, 0x1c, 0x7e, 0x6c, 0x42, 0xc1,
    0x7c, 0x4f, 0xf3, 0x4c, 0x0c, 0xf0, 0xc0, 0xc3,
    0xd1, 0x70, 0x82, 0xd7, 0x5b, 0xcf, 0x18, 0xa0,
    0x01, 0x8c, 0xf3, 0xa5, 0x9e, 0xf2, 0xf2, 0x0e,
    0x00, 0xe2, 0xb8, 0xf0, 0x76, 0xe1, 0x9e, 0x4e,
    0x2f, 0x16, 0xca, 0xde, 0x3f, 0x43, 0xfa, 0x86,
    0x8a, 0x55, 0x7c, 0xca, 0x90, 0xb2, 0x37, 0x31,
    0xa4, 0xf1, 0xc4, 0x48, 0x9e, 0x14, 0xa8, 0x87,
    0x01, 0xc9, 0x51, 0x31, 0xb4, 0xdf, 0xf8, 0x70,
    0x24, 0xd0, 0xe5, 0x2d, 0xb5, 0xc2, 0x25, 0xbc,
    0x56, 0x67, 0x8d, 0xa8, 0xf7, 0x0f, 0x64, 0x37,
    0x12, 0x9d, 0x9c, 0x00, 0x3a, 0xc1, 0x9b, 0xa1,
    0xa3, 0xf5, 0xc6, 0x6a, 0x66, 0xf7, 0xd1, 0x1d,
    0x40, 0x6a, 0xc7, 0xd7, 0x3a, 0xb4, 0x08, 0x15,
    0x89, 0x82, 0x27, 0xdd, 0x51, 0xd8, 0x27, 0xef,
    0x49, 0x58, 0x8b, 0xf4, 0xa2, 0x97, 0x37, 0x96,
    0xfe, 0xaf, 0x6b, 0x84, 0x9b, 0xe6, 0x42, 0x0c,
    0x39, 0x1e, 0x1e, 0xca, 0x7d, 0x66, 0x04, 0x43,
    0xed, 0xd8, 0x92, 0xde, 0x19, 0x3a, 0x00, 0xc3,
    0x1c, 0x84, 0xe0, 0x0f, 0x9c, 0x1b, 0x14, 0xf3,
    0xa2, 0x0e, 0x6c, 0x3a, 0xdb, 0xe2, 0x4b, 0x26,
    0xe5, 0x6f, 0xbb, 0x68, 0xd3, 0x5c, 0x1d, 0x54,
    0xf3, 0x14, 0x0a, 0x2e, 0x8c, 0x1f, 0x28, 0x48,
    0xfe, 0x03, 0x1d, 0x6f, 0x47, 0x1d, 0x17, 0x0e,
    0xae, 0x4a, 0x42, 0x36, 0xd6, 0x43, 0x15, 0x70,
    0x0d, 0xa8, 0x6f, 0x5a, 0x67, 0xf7, 0x07, 0xbc,
    0x3e, 0xa9, 0xe0, 0xc5, 0x59, 0x00, 0x03, 0xd9,
    0x00, 0x02, 0xf8, 0x42, 0x3d, 0xb2, 0x37, 0x3a,
    0xa4, 0xfa, 0xc3, 0x86, 0x80, 0xef, 0xdd, 0x32,
    0x12, 0x32, 0xd1, 0x4d, 0x82, 0x7b, 0x1f, 0x9f,
    0xaf, 0xd8, 0x20, 0xa2, 0xcf, 0xcc, 0x39, 0x21,
    0x76, 0x3e, 0x2f, 0x4c, 0x65, 0x78, 0xda, 0x9a,
    0xec, 0xeb, 0xfc, 0xd7, 0x86, 0xcc, 0x4f, 0xf0,
    0x2b, 0xf4, 0x7b, 0x01, 0x75, 0x8d, 0x5a, 0x95,
    0xea, 0x37, 0x00, 0xbc, 0xa5, 0x6e, 0x5a, 0x54,
    0xec, 0xb9, 0x2d, 0xd0, 0x40, 0xe7, 0xae, 0xda,
    0x0d, 0x0f, 0x3a, 0x7a, 0x3d, 0xfa, 0xc2, 0xea,
    0x3e, 0xde, 0x2f, 0x88, 0x65, 0xa9, 0x10, 0x05,
    0x2b, 0xda, 0xe7, 0x93, 0x9a, 0x10, 0x66, 0x0f,
    0x7f, 0x7c, 0x82, 0x0e, 0xdf, 0xdd, 0xd8, 0xa3,
    0xc6, 0xc2, 0x3b, 0xd6, 0xe0, 0x8f, 0x8d, 0xed,
    0x14, 0x28, 0xa4, 0x0a, 0xe4, 0xcc, 0x4f, 0x56,
    0x8d, 0x98, 0x50, 0x6d, 0x3a, 0x7e, 0x71, 0x05,
    0x88, 0xbb, 0xa8, 0xb2, 0x0d, 0x74, 0xbb, 0x81,
    0x4c, 0x98, 0x04, 0xca, 0x45, 0x8e, 0xcb, 0x3f,
    0x3e, 0xf0, 0x9c, 0xf5, 0xca, 0xde, 0x10, 0x37,
    0x3d, 0x0e, 0xad, 0xc8, 0xa5, 0xfd, 0xa9, 0x6e,
    0xed, 0x44, 0x96, 0x28, 0x73, 0xdc, 0x80, 0xf8,
    0x22, 0xd7, 0xba, 0x57, 0x81, 0x3c, 0x7d, 0xf5,
    0xf8, 0xa5, 0xe2, 0xba, 0x2b, 0x77, 0x4d, 0x15,
    0x96, 0xf1, 0xe7, 0x92, 0xea, 0x64, 0x43, 0x0b,
    0x4d, 0x50, 0x97, 0xe5, 0x69, 0xd2, 0xa2, 0xc9,
    0x9e, 0x1d, 0xb8, 0x3f, 0xc2, 0x78, 0xd4, 0x34,
    0xd7, 0x6f, 0x0b, 0x74, 0x91, 0xf6, 0xcd, 0x49,
    0x3d, 0xa8, 0x0b, 0x47, 0x45, 0x4b, 0xc0, 0x23,
    0x8d, 0x1a, 0xd2, 0xbc, 0x88, 0x12, 0xe4, 0x25,
    0x38, 0xcc, 0x45, 0xcf, 0x23, 0xc8, 0x20, 0xea,
    0xd9, 0x88, 0xbb, 0x41, 0x89, 0x31, 0x43, 0x61,
    0x4f, 0x92, 0x05, 0x67, 0xbc, 0xe5, 0x17, 0x2b,
    0x0a, 0xab, 0xb6, 0xb9, 0x31, 0xfa, 0x01, 0x63,
    0x6b, 0x1d, 0xda, 0x03, 0xa5, 0x81, 0x23, 0xe0,
    0xf9, 0xfb, 0x21, 0xf0, 0xd1, 0x0c, 0xca, 0x2d,
    0x6b, 0xd9, 0xbc, 0xd0, 0x20, 0xb6, 0x63, 0x0d,
    0xd9, 0x21, 0x94, 0x9f, 0x59, 0xb2, 0xa0, 0xf9,
    0xa1, 0x6a, 0x3b, 0xbf, 0xdf, 0x08, 0x7e, 0x56,
    0x0e, 0xae, 0x8a, 0x61, 0xa1, 0x21, 0x27, 0x4e,
    0xf2, 0x90, 0x47, 0x2e, 0x3c, 0x8a, 0x35, 0xc5,
    0xfc, 0xae, 0xbc, 0x1a, 0xa7, 0x6f, 0x36, 0x35,
    0x2c, 0x9b, 0x52, 0x37, 0x4f, 0x16, 0x56, 0xdb,
    0x35, 0x2d, 0xa8, 0x50, 0x2e, 0x2a, 0x02, 0x91,
    0xbb, 0x52, 0x3e, 0xf9, 0x46, 0xe2, 0x76, 0x3a,
    0x50, 0xd5, 0x6d, 0xe5, 0xff, 0xb8, 0x39, 0x53,
    0x2e, 0x26, 0x10, 0xa9, 0xc7, 0x17, 0x2b, 0xea,
    0x5f, 0x6b, 0x99, 0xe1, 0x75, 0xce, 0x29, 0x76,
    0xb6, 0x19, 0x17, 0xe3, 0xc6, 0xed, 0xd1, 0x3d,
    0x42, 0xa0, 0x1e, 0xc0, 0xb5, 0x8c, 0xd8, 0x23,
    0x13, 0x22, 0x36, 0x0a, 0x7c, 0x8b, 0x40, 0x43,
    0x61, 0x7c, 0xaf, 0xbf, 0x0a, 0x6e, 0xd6, 0x0f,
    0x3f, 0xd5, 0xd4, 0x8a, 0x7c, 0x9f, 0xfe, 0x53,
    0xd0, 0x36, 0xd8, 0xe2, 0xe9, 0xbc, 0x2b, 0x83,
    0x85, 0x5e, 0x71, 0x58, 0x68, 0xe1, 0xc6, 0xd8,
    0x58, 0x13, 0xb8, 0x6c, 0x73, 0xa6, 0xd9, 0xd1,
    0x0c, 0xaa, 0xa0, 0xa2, 0x10, 0xed, 0x20, 0xd8,
    0x63, 0xe5, 0x9e, 0xd4, 0xea, 0x2b, 0x2b, 0xb7,
    0x95, 0x0b, 0x9e, 0x56, 0x0c, 0x4d, 0x68, 0xf1,
    0x6c, 0xdf, 0x7f, 0xca, 0x47, 0x8e, 0x98, 0x63,
    0x07, 0x3a, 0x67, 0xce, 0x16, 0x63, 0xa7, 0xf9,
    0xd3, 0x2c, 0x47, 0xbc, 0x14, 0x07, 0x2f, 0xdb,
    0xd6, 0xea, 0xae, 0x4e, 0xd9, 0xac, 0x79, 0x76,
    0x8e, 0x3b, 0x2d, 0xa8, 0x71, 0x64, 0xcf, 0x43,
    0x5b, 0xb3, 0xdb, 0x19, 0x67, 0xce, 0xf8, 0x90,
    0xfd, 0xb7, 0x2e, 0xb9, 0x10, 0xdd, 0xa5, 0x24,
    0xa5, 0xd9, 0x08, 0x1e, 0x8e, 0x86, 0x04, 0x29,
    0xd8, 0x5a, 0xdf, 0xce, 0xdc, 0x9a, 0xcf, 0xbf,
    0xf6, 0x86, 0xec, 0xec, 0x0b, 0x16, 0xa2, 0x43,
    0x66, 0x19, 0x13, 0xb3, 0xc5, 0x08, 0xfd, 0xc8,
    0xba, 0x48, 0xb9, 0x55, 0x88, 0x79, 0xa5, 0x5c,
    0x6c, 0x56, 0xcc, 0xf6, 0xbc, 0x4a, 0x37, 0x2c,
    0x90, 0xc9, 0xdd, 0xf2, 0x08, 0x85, 0x55, 0x22,
    0x29, 0x4b, 0x15, 0x92, 0x6c, 0xad, 0xc6, 0xac,
    0x2a, 0xd2, 0x15, 0x7b, 0x90, 0x3e, 0x6e, 0xc8,
    0xeb, 0x30, 0x42, 0xed, 0xcd, 0xed, 0xcf, 0xb3,
    0x71, 0x72, 0x4b, 0x71, 0x9e, 0xd3, 0xe8, 0xfe,
    0x5b, 0x26, 0x6e, 0x53, 0xd5, 0x27, 0x5f, 0x01,
    0xda, 0x61, 0x19, 0x92, 0x59, 0xda, 0xbc, 0x00,
    0x95, 0xc6, 0x55, 0xe8, 0xb3, 0x4f, 0x41, 0xb0,
    0x6d, 0xf8, 0x24, 0x86, 0x1f, 0x58, 0xd6, 0x45,
    0x8e, 0x91, 0x35, 0xb5, 0xdc, 0x57, 0xfd, 0x4b,
    0x4b, 0x1e, 0x9b, 0x87, 0x4f, 0xe8, 0x0b, 0x15,
    0x95, 0x32, 0xf8, 0xd8, 0x80, 0x35, 0x3a, 0x5c,
    0xa0, 0xab, 0x24, 0x50, 0xd3, 0x76, 0x66, 0xa8,
    0xf7, 0x7e, 0x6d, 0xf8, 0x6e, 0xe5, 0x3d, 0x2f,
    0xd2, 0x37, 0x2d, 0x84, 0x31, 0x55, 0x9a, 0x30,
    0xc3, 0xf7, 0xcc, 0x3e, 0x56, 0xce, 0xdd, 0x46,
    0x39, 0xf1, 0x4d, 0xfd, 0xd9, 0x84, 0xb9, 0xe2,
    0x50, 0x55, 0x11, 0x85, 0xbb, 0xec, 0xaa, 0xa7,
    0x91, 0x8f, 0x98, 0xa0, 0x30, 0x42, 0x20, 0x1b,
    0x14, 0xca, 0x47, 0x8d, 0xbf, 0x42, 0xe5, 0x97,
    0x5d, 0x4b, 0x04, 0x3d, 0xbc, 0xc9, 0x29, 0x24,
    0xd2, 0xdf, 0x38, 0xd7, 0x1f, 0xfc, 0x3c, 0x78,
    0xe6, 0xed, 0x51, 0xfa, 0x5c, 0x48, 0x16, 0xd7,
    0x8f, 0x8a, 0x46, 0x9c, 0xe0, 0x44, 0xd4, 0x0c,
    0x7a, 0x49, 0xa0, 0x83, 0x76, 0x8f, 0xa6, 0x1d,
    0x44, 0xb6, 0x8e, 0x6f, 0x7b, 0x0e, 0x4d, 0xc4,
    0x77, 0x2c, 0x5a, 0x2c, 0x06, 0xe7, 0x45, 0x0b,
    0x30, 0x0d, 0x24, 0x71, 0x16, 0x53, 0x7c, 0x84,
    0x49, 0x2b, 0x2a, 0xf4, 0x5b, 0x34, 0xf0, 0x2e,
    0xa6, 0x1a, 0x04, 0xf5, 0x5d, 0x35, 0x50, 0xc2,
    0x9e, 0x81, 0x28, 0x27, 0xb3, 0xd1, 0x9f, 0x81,
    0xff, 0x80, 0xfd, 0x51, 0x34, 0xb4, 0x8d, 0x73,
    0x3a, 0x0a, 0xe9, 0x39, 0xe4, 0x35, 0x2f, 0xb5,
    0x57, 0x31, 0x59, 0x3d, 0x9d, 0x83, 0xc2, 0x1c,
    0x80, 0xe3, 0x7a, 0x85, 0xff, 0x14, 0x8c, 0x9e,
    0x8d, 0x80, 0x75, 0x36, 0x2c, 0xa8, 0xf7, 0x7e,
    0x69, 0x1f, 0xc7, 0xc8, 0x2b, 0x56, 0x2e, 0x43,
    0x66, 0x19, 0xa1, 0x42, 0x08, 0x93, 0x86, 0x38,
    0x63, 0xc6, 0x06, 0x62, 0x17, 0xee, 0x5c, 0x67,
    0x7a, 0x78, 0x31, 0xd2, 0x36, 0xee, 0x5a, 0x4f,
    0xbf, 0xfa, 0x86, 0xcd, 0xae, 0xae, 0x5c, 0x1f,
    0xcc, 0xd0, 0xf5, 0x2b, 0xe6, 0x4e, 0x3e, 0x1b,
    0xcd, 0x9a, 0x9b, 0x71, 0x23, 0x72, 0x16, 0xec,
    0x50, 0xeb, 0x17, 0x3b, 0x84, 0x29, 0xa6, 0x1c,
    0x2f, 0xe3, 0xce, 0xdf, 0xe8, 0xd3, 0x17, 0xfc,
    0x02, 0x94, 0xe9, 0x62, 0x4b, 0x8d, 0xc9, 0xb0,
    0xf2, 0x32, 0xa0, 0x6e, 0x3c, 0xc8, 0x3e, 0xa7,
    0x9d, 0x18, 0x98, 0xf1, 0x39, 0xa0, 0x76, 0xb3,
    0xab, 0x21, 0x12, 0xdc, 0xbe, 0x5e, 0x32, 0xab,
    0xdd, 0x69, 0x32, 0xf5, 0xdb, 0x93, 0xb5, 0x29,
    0xde, 0x56, 0x67, 0x5d, 0x1a, 0x84, 0x34, 0xf4,
    0x6e, 0x82, 0x7a, 0xde, 0xc3, 0x2c, 0x70, 0x86,
    0x55, 0xfb, 0x1c, 0x7b, 0x88, 0x1b, 0xe0, 0x2b,
    0x36, 0xb5, 0x51, 0xc9, 0xf9, 0xc0, 0xfa, 0x8c,
    0x46, 0x26, 0x64, 0x4f, 0x21, 0x1d, 0xb1, 0x21,
    0x3c, 0xf3, 0x91, 0xc9, 0x19, 0x9c, 0xf9, 0xd9,
    0x3f, 0x19, 0x8d, 0x70, 0x9f, 0xc5, 0x65, 0x91,
    0x24, 0x8a, 0xcc, 0xc8, 0x90, 0x6e, 0xab, 0xae,
    0x8e, 0x3f, 0x3f, 0xae, 0x0d, 0xc9, 0x10, 0x70,
    0xe5, 0x21, 0xeb, 0x54, 0x83, 0x6c, 0x1e, 0x17,
    0x59, 0xdd, 0x52, 0x50, 0xb4, 0xd0, 0xf1, 0xf0,
    0xd5, 0x88, 0x8c, 0xd2, 0xcc, 0x0f, 0x89, 0x44,
    0x14, 0x31, 0x71, 0xf0, 0x73, 0xa3, 0xd1, 0x2c,
    0x16, 0xe0, 0x91, 0xb7, 0x14, 0x63, 0xd4, 0xfb,
    0xc5, 0xbe, 0x72, 0x65, 0xfc, 0x0d, 0x8a, 0x73,
    0x3f, 0x2b, 0x4e, 0x1a, 0xa4, 0x59, 0x90, 0x5c,
    0xbf, 0xc4, 0xf7, 0x13, 0xa1, 0xf3, 0x96, 0xef,
    0x06, 0xfb, 0x6a, 0xb9, 0x91, 0x41, 0xb3, 0x25,
    0x9e, 0x87, 0x05, 0xf8, 0x7d, 0xf2, 0x51, 0x4c,
    0xba, 0xac, 0xbf, 0xb9, 0x5b, 0xc0, 0x53, 0x84,
    0x3f, 0xb4, 0xd5, 0xe6, 0xc9, 0xda, 0x41, 0xc0,
    0xbc, 0xdb, 0x85, 0x09, 0xc8, 0x6c, 0x95, 0x6a,
    0x63, 0xc5, 0x5e, 0x72, 0xf2, 0x6f, 0x99, 0x99,
    0x71, 0x8a, 0x45, 0xa1, 0xd1, 0xdd, 0x92, 0x06,
    0xd6, 0x9f, 0x5c, 0xbb, 0x22, 0x7a, 0xd6, 0x57,
    0x9d, 0x1c, 0x32, 0x06, 0x21, 0x2d, 0x59, 0x1b,
    0x61, 0xd4, 0x7c, 0x76, 0x15, 0x34, 0x81, 0xc2,
    0x74, 0x4f, 0x2f, 0xe5, 0xb6, 0x83, 0xcc, 0x0f,
    0x99, 0x83, 0x03, 0x77, 0x3a, 0x62, 0xdc, 0xb5,
    0x53, 0x5c, 0xe2, 0x87, 0x2f, 0xca, 0xd6, 0x8a,
    0x3e, 0xad, 0x05, 0x74, 0x44, 0xb0, 0x84, 0x53,
    0xee, 0x87, 0x19, 0xa6, 0x19, 0x8d, 0x98, 0xb2,
    0xe6, 0x2f, 0xdc, 0x3a, 0xd7, 0xc9, 0x2b, 0x16,
    0x0c, 0xc4, 0x39, 0xec, 0x89, 0x62, 0x0f, 0xd8,
    0x19, 0xb2, 0x93, 0xef, 0xfd, 0x9a, 0xf1, 0xe3,
    0x33, 0x27, 0x09, 0xaa, 0x75, 0x5f, 0x68, 0x9a,
    0x44, 0x4b, 0xe1, 0x12, 0x52, 0x5f, 0xc3, 0x0c,
    0xbf, 0xee, 0xd9, 0xc0, 0x73, 0xf3, 0x09, 0x77,
    0x39, 0xea, 0x50, 0x0f, 0x30, 0xa6, 0x9c, 0xa2,
    0x20, 0xbe, 0xdd, 0x3b, 0xd0, 0x11, 0x33, 0x44,
    0xc2, 0xb4, 0x3b, 0x74, 0xad, 0x27, 0x6c, 0x6b,
    0xd6, 0xff, 0xfc, 0xc9, 0x24, 0x4b, 0x21, 0x6b,
    0x61, 0x71, 0x27, 0x6c, 0x7c, 0xf7, 0x72, 0xf8,
    0xb6, 0x98, 0x2f, 0x5c, 0x13, 0x05, 0x28, 0x80,
    0xc6, 0x51, 0x7f, 0xda, 0x09, 0xe0, 0x42, 0xb1,
    0xc2, 0xb9, 0xe6, 0xaa, 0xca, 0xe0, 0xa4, 0x07,
    0xbc, 0x44, 0x8a, 0x44, 0x32, 0xa9, 0x14, 0xf1,
    0x1d, 0xb4, 0xcf, 0x2f, 0x2e, 0x7e, 0x78, 0xfd,
    0x47, 0x92, 0x62, 0x30, 0xff, 0xdd, 0x30, 0x62,
    0xc7, 0x5e, 0x7a, 0x69, 0x2e, 0x99, 0xae, 0xae,
    0xde, 0x89, 0x93, 0x1b, 0xa2, 0x22, 0xfb, 0x42,
    0xc1, 0xcd, 0x09, 0x2f, 0x4a, 0x41, 0xfa, 0xa7,
    0x74, 0x53, 0x05, 0x88, 0x73, 0xd5, 0x69, 0x65,
    0xc2, 0x52, 0x76, 0x48, 0xb2, 0xc0, 0xcf, 0x42,
    0x98, 0x76, 0x39, 0x0c, 0xfb, 0x7c, 0xfa, 0xd6,
    0x7c, 0x5f, 0x23, 0x9b, 0x33, 0xdb, 0x44, 0x0a,
    0x21, 0xc3, 0x9a, 0x81, 0x64, 0x77, 0x5a, 0xd0,
    0x0e, 0x8f, 0xa2, 0xa7, 0x3f, 0xa5, 0xa6, 0x2b,
    0xae, 0xa3, 0xa9, 0xd4, 0x38, 0x00, 0x22, 0x80,
    0x2c, 0x04, 0x14, 0x4f, 0x8b, 0x49, 0x90, 0x8b,
    0x14, 0x0a, 0x25, 0xad, 0xe6, 0x11, 0x06, 0xb1,
    0x90, 0x83, 0x33, 0xe7, 0xd2, 0x11, 0x44, 0x16,
    0xb9, 0x16, 0x63, 0x55, 0x17, 0xcf, 0xce, 0x07,
    0xe2, 0xa3, 0xbe, 0x83, 0x88, 0xb7, 0xfe, 0x6d,
    0xd9, 0x03, 0x23, 0x34, 0x8c, 0x3f, 0x2b, 0x93,
    0x6b, 0x06, 0x59, 0x5f, 0x58, 0x0d, 0x63, 0xe3,
    0x8d, 0x41, 0x66, 0x1e, 0x7f, 0x5e, 0xfb, 0x32,
    0x97, 0x9c, 0x1a, 0x85, 0x0e, 0xc0, 0x1e, 0x29,
    0x77, 0x80, 0xb2, 0x90, 0x13, 0x74, 0x1c, 0x55,
    0x99, 0xf7, 0xeb, 0x16, 0x61, 0xc6, 0xa6, 0x51,
    0xcc, 0xed, 0x07, 0x68, 0xc8, 0xb2, 0xd5, 0xcf,
    0x23, 0xd8, 0xc0, 0xf4, 0x6a, 0xb6, 0x14, 0xb4,
    0xd1, 0xc7, 0xa6, 0x44, 0x54, 0x34, 0x06, 0x78,
    0x0e, 0x9c, 0x10, 0x2a, 0xf2, 0x6b, 0x6c, 0x07,
    0x05, 0x0a, 0x36, 0xfc, 0x1d, 0x7c, 0xc5, 0x33,
    0x65, 0x3e, 0x40, 0x83, 0x56, 0xa8, 0x6d, 0xa6,
    0x9f, 0x3a, 0x38, 0x89, 0x6f, 0xd0, 0xa2, 0xa6,
    0xf1, 0xa2, 0xbd, 0x26, 0xbd, 0x39, 0xe2, 0xcf,
    0x32, 0xe3, 0x58, 0x4c, 0x4f, 0x49, 0x03, 0xd4,
    0x44, 0x45, 0xa8, 0xf7, 0xc6, 0x9a, 0x80, 0x33,
    0x8a, 0x75, 0xc9, 0x31, 0xa0, 0x74, 0xe1, 0x9d,
    0x04, 0x0b, 0xa9, 0x4a, 0x73, 0xb8, 0x1a, 0x74,
    0xf8, 0xba, 0xea, 0x89, 0x75, 0x7f, 0x1b, 0xe6,
    0x8f, 0x6e, 0xb4, 0x52, 0xa0, 0xb1, 0x92, 0x06,
    0x52, 0xbc, 0x5f, 0x9f, 0x79, 0xea, 0xb5, 0xbf,
    0xbd, 0x8c, 0x9e, 0x8d, 0x3e, 0xbe, 0xbe, 0x69,
    0xdb, 0xa9, 0x4d, 0xb8, 0xee, 0xc4, 0x54, 0x71,
    0xbc, 0x12, 0x45, 0x7b, 0xdd, 0x05, 0x50, 0xa9,
    0xc3, 0x89, 0xe5, 0xc9, 0x26, 0x42, 0x58, 0x59,
    0xec, 0xbc, 0x23, 0x06, 0xe4, 0x79, 0x2c, 0xbd,
    0x92, 0x75, 0x78, 0x42, 0x62, 0x58, 0x94, 0x0a,
    0x47, 0xea, 0xdc, 0xbc, 0x33, 0x07, 0x1e, 0x79,
    0xe9, 0x31, 0xf8, 0x3f, 0x86, 0x2e, 0x89, 0x1c,
    0xa4, 0xe1, 0xdc, 0xdc, 0xe3, 0x67, 0xa6, 0xfd,
    0x05, 0x6f, 0x17, 0x7f, 0x6c, 0x6a, 0xb2, 0x99,
    0x16, 0x2f, 0x0d, 0x9f, 0x76, 0xe8, 0xba, 0x15,
    0xfa, 0x31, 0x79, 0x70, 0x5b, 0xea, 0x0a, 0x14,
    0x82, 0x78, 0x47, 0x15, 0x6c, 0x6f, 0xde, 0x16,
    0x74, 0xec, 0x32, 0x96, 0xec, 0x53, 0xda, 0xe7,
    0xcc, 0xd9, 0xc3, 0x0e, 0xdf, 0x9d, 0xb1, 0x92,
    0xfb, 0x3d, 0x4f, 0xdd, 0x32, 0x32, 0xaf, 0x42,
    0x49, 0x92, 0x8e, 0x81, 0xdf, 0xf5, 0x21, 0xce,
    0xa0, 0x01, 0xe9, 0x8d, 0xd9, 0xe4, 0xc8, 0xfa,
    0x88, 0x77, 0xe5, 0xde, 0x74, 0xeb, 0x95, 0xcf,
    0xa7, 0xa9, 0x00, 0xa7, 0x8a, 0x2c, 0xbd, 0x12,
    0xd5, 0xae, 0x63, 0xce, 0x0e, 0x95, 0xa8, 0x11,
    0xb6, 0x2f, 0x92, 0x39, 0x64, 0xdc, 0x15, 0x0b,
    0x54, 0xac, 0x03, 0x40, 0xba, 0x83, 0xb6, 0x73,
    0x6e, 0x82, 0x56, 0x2f, 0x2e, 0xaf, 0xf8, 0xeb,
    0x08, 0x00, 0x21, 0xd7, 0x0a, 0x8f, 0xdd, 0x0e,
    0x01, 0x02, 0x91, 0x62, 0x07, 0x3c, 0x5d, 0x21,
    0xd5, 0xe2, 0x31, 0xa8, 0xa1, 0x49, 0xe1, 0xce,
    0x6c, 0x2b, 0xe7, 0x22, 0xfc, 0x08, 0x03, 0xe2,
    0xe6, 0x66, 0xfb, 0xf2, 0x0e, 0xba, 0x8d, 0xae,
    0x98, 0xf8, 0x6f, 0xb1, 0xfe, 0xd4, 0x9a, 0x78,
    0xab, 0x9f, 0x1f, 0x0f, 0x35, 0xd5, 0xb5, 0xd9,
    0xc2, 0xf3, 0xd4, 0xa0, 0x8b, 0x0a, 0x8a, 0x03,
    0xe0, 0x73, 0xee, 0x5f, 0xbf, 0x17, 0x01, 0x01,
    0x46, 0xa0, 0x73, 0xa5, 0x8f, 0x41, 0xb4, 0xda,
    0x93, 0xf3, 0x54, 0x8a, 0xbc, 0xc2, 0x5f, 0x28,
    0x53, 0x0b, 0x2a, 0x36, 0x4e, 0x86, 0x99, 0x18,
    0x61, 0x45, 0x29, 0xf1, 0x08, 0xe7, 0xb0, 0xea,
    0xde, 0xde, 0xcd, 0x39, 0x78, 0x92, 0x4e, 0x28,
    0x5a, 0xe7, 0x9a, 0x0c, 0xe2, 0x15, 0x00, 0x8a,
    0xf3, 0x3d, 0x8c, 0x3e, 0xdc, 0x49, 0x68, 0x24,
    0x7a, 0xd6, 0x03, 0x3b, 0xab, 0x6d, 0x5c, 0x07,
    0xb4, 0xcf, 0x2d, 0x81, 0xe5, 0xde, 0x9e, 0x93,
    0x3a, 0xa9, 0x48, 0x56, 0xb1, 0x7b, 0x51, 0xd5,
    0x88, 0xbd, 0x46, 0x9a, 0xe0, 0x4e, 0xdc, 0x7e,
    0x5f, 0x1d, 0xb8, 0xf2, 0x66, 0x2f, 0xdc, 0x1b,
    0x95, 0xa8, 0xb3, 0xe4, 0x2b, 0xb5, 0xe8, 0x52,
    0x26, 0xce, 0xff, 0x5d, 0x38, 0xf2, 0x66, 0x4e,
    0xff, 0x5d, 0x38, 0xd3, 0x05, 0x69, 0x31, 0xe0,
    0x42, 0x06, 0x8e, 0x7f, 0x7c, 0x5b, 0x34, 0xcb,
    0xf5, 0x68, 0x52, 0x26, 0xce, 0xff, 0x7c, 0x7a,
    0x76, 0x6e, 0x3f, 0xdd, 0x19, 0xb0, 0xc3, 0x04,
    0x8a, 0x96, 0x8f, 0x9c, 0x9b, 0x95, 0x89, 0x90,
    0x83, 0x84, 0x6b, 0x54, 0x0b, 0x75, 0x49, 0x10,
    0x83, 0x65, 0x48, 0x12, 0x87, 0x6d, 0x39, 0xf0,
    0x43, 0x04, 0x8a, 0x96, 0x8f, 0x9c, 0xba, 0xd7,
    0x0d, 0x79, 0x51, 0x20, 0xa3, 0xc4, 0xeb, 0x54,
    0x2a, 0xb7, 0xcd, 0x18, 0xb2, 0xe6, 0x4e, 0xff,
    0x7c, 0x7a, 0x57, 0x2c, 0xbb, 0xf4, 0x6a, 0x37,
    0xcd, 0x18, 0x93, 0xa4, 0xca, 0x16, 0x8f, 0x7d,
    0x78, 0x53, 0x24, 0xca, 0x16, 0x8f, 0x7d, 0x78,
    0x72, 0x66, 0x2f, 0xbd, 0xd9, 0x11, 0xa0, 0xc2,
    0x06, 0x8e, 0x7f, 0x7c, 0x5b, 0x15, 0x89, 0x90,
    0x83, 0x84, 0x8a, 0x96, 0x8f, 0x7d, 0x78, 0x72,
    0x47, 0x0c, 0x9a, 0x97, 0xac, 0xda, 0x36, 0xee,
    0x5e, 0x1f, 0x9d, 0x99, 0xb0, 0xe2, 0x46, 0xef,
    0x3d, 0xd9, 0x30, 0xc3, 0x04, 0x8a, 0x77, 0x6c,
    0x5a, 0x36, 0xcf, 0x1c, 0x9b, 0xb4, 0xea, 0x56,
    0x2e, 0xde, 0x3e, 0xdf, 0x3c, 0xfa, 0x76, 0x6e,
    0x3f, 0xdd, 0x19, 0xb0, 0xe2, 0x27, 0xad, 0xd8,
    0x13, 0xa4, 0xab, 0xb5, 0xc9, 0x10, 0xa2, 0xc6,
    0xef, 0x3d, 0xd9, 0x11, 0x81, 0x80, 0x63, 0x44,
    0xeb, 0x54, 0x0b, 0x94, 0xaa, 0xd6, 0x0f, 0x7d,
    0x59, 0x11, 0xa0, 0xa3, 0xc4, 0xeb, 0x54, 0x0b,
    0x75, 0x68, 0x33, 0xc5, 0x08, 0x92, 0x87, 0x6d,
    0x39, 0xf0, 0x43, 0x04, 0x6b, 0x54, 0x2a, 0xd6,
    0x0f, 0x9c, 0xba, 0xf6, 0x6e, 0x3f, 0xdd, 0x19,
    0x91, 0x81, 0x80, 0x82, 0x67, 0x2d, 0xb9, 0xf0,
    0x62, 0x27, 0xcc, 0xfb, 0x74, 0x4b, 0x14, 0xaa,
    0xb7, 0xec, 0x3b, 0xf4, 0x4b, 0x14, 0x8b, 0x75,
    0x49, 0xf1, 0x60, 0x42, 0x06, 0x8e, 0x7f, 0x7c,
    0x7a, 0x57, 0x0d, 0x98, 0xb2, 0xe6, 0x4e, 0x1e,
    0xbe, 0xdf, 0x3c, 0xdb, 0x34, 0xea, 0x56, 0x0f,
    0x7d, 0x59, 0x11, 0xa0, 0xc2, 0xe7, 0x2d, 0xb9,
    0xd1, 0x01, 0x80, 0x63, 0x44, 0xeb, 0x54, 0x2a,
    0xb7, 0xcd, 0xf9, 0x51, 0x01, 0x61, 0x21, 0xc0,
    0x02, 0x67, 0x2d, 0xd8, 0x13, 0x85, 0x88, 0x73,
    0x45, 0xe9, 0x31, 0xe0, 0x42, 0x06, 0x6f, 0x5c,
    0x3a, 0xd7, 0x0d, 0x79, 0x51, 0x20, 0xa3, 0xc4,
    0x0a, 0x77, 0x6c, 0x3b, 0xd5, 0x28, 0xd2, 0x26,
    0xaf, 0xbd, 0xf8, 0x53, 0x24, 0xca, 0xf7, 0x4d,
    0x18, 0x93, 0xa4, 0xab, 0xb5, 0xc9, 0xf1, 0x60,
    0x42, 0x06, 0x8e, 0x7f, 0x5d, 0x19, 0xb0, 0xc3,
    0x04, 0x8a, 0x96, 0xae, 0xbf, 0xfc, 0x5b, 0x15,
    0xa8, 0xb3, 0xe4, 0x4a, 0xf7, 0x4d, 0x18, 0xb2,
    0xc7, 0xed, 0x58, 0x32, 0xc7, 0xed, 0x39, 0xd1,
    0x01, 0x80, 0x63, 0x44, 0x0a, 0x77, 0x6c, 0x3b,
    0xf4, 0x6a, 0x56, 0x2e, 0xde, 0x1f, 0xbc, 0xfa,
    0x57, 0x2c, 0xbb, 0xd5, 0x09, 0x71, 0x41, 0xe1,
    0x40, 0x02, 0x67, 0x4c, 0x1a, 0x97, 0xac, 0xbb,
    0xd5, 0x28, 0xb3, 0xe4, 0x4a, 0x16, 0xae, 0xbf,
    0xdd, 0x19, 0xb0, 0xe2, 0x46, 0xef, 0x3d, 0xd9,
    0x11, 0x81, 0x61, 0x40, 0xe3, 0x44, 0x0a, 0x77,
    0x6c, 0x5a, 0x17, 0x8d, 0x79, 0x51, 0x20, 0xa3,
    0xc4, 0x0a, 0x77, 0x4d, 0x18, 0x93, 0xa4, 0xca,
    0x16, 0x8f, 0x7d, 0x59, 0x30, 0xe2, 0x46, 0x0e,
    0x7f, 0x5d, 0x38, 0xf2, 0x47, 0xed, 0x39, 0xf0,
    0x43, 0x04, 0x17, 0x22, 0xbf, 0xbb
};

